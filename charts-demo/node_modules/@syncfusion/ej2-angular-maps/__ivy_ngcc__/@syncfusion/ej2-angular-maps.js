import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, Directive, ElementRef, Injector, NgModule, Renderer2, ViewContainerRef } from '@angular/core';
import { ArrayBase, ComplexBase, ComponentBase, ComponentMixins, Template, setValue } from '@syncfusion/ej2-angular-base';
import { Annotations, Bubble, DataLabel, Highlight, ImageExport, Legend, Maps, MapsTooltip, Marker, NavigationLine, PdfExport, Print, Selection, Zoom } from '@syncfusion/ej2-maps';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["template"];
const _c1 = ["tooltipSettingsTemplate"];
const _c2 = ["content"];
let input = ['shapePath', 'shapeValue'];
let outputs = [];
/**
 * Layer Directive
 * ```html
 * <e-layers>
 * <e-layer>
 * <e-initialShapeSelections>
 * <e-initialShapeSelection>
 * </e-initialShapeSelection>
 * </e-initialShapeSelections>
 * </e-layer>
 * </e-layers>
 * ```
 */
class InitialShapeSelectionDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs);
        this.directivePropList = input;
    }
}
InitialShapeSelectionDirective.ɵfac = function InitialShapeSelectionDirective_Factory(t) { return new (t || InitialShapeSelectionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
InitialShapeSelectionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: InitialShapeSelectionDirective, selectors: [["e-initialShapeSelection"]], inputs: { shapePath: "shapePath", shapeValue: "shapeValue" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
InitialShapeSelectionDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
/**
 * InitialShapeSelection Array Directive
 */
class InitialShapeSelectionsDirective extends ArrayBase {
    constructor() {
        super('initialshapeselection');
    }
}
InitialShapeSelectionsDirective.ɵfac = function InitialShapeSelectionsDirective_Factory(t) { return new (t || InitialShapeSelectionsDirective)(); };
InitialShapeSelectionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: InitialShapeSelectionsDirective, selectors: [["e-initialShapeSelections"]], contentQueries: function InitialShapeSelectionsDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, InitialShapeSelectionDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
InitialShapeSelectionsDirective.ctorParameters = () => [];

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let input$1 = ['animationDelay', 'animationDuration', 'border', 'colorValuePath', 'dashArray', 'dataSource', 'fill', 'height', 'highlightSettings', 'imageUrl', 'imageUrlValuePath', 'initialMarkerSelection', 'latitudeValuePath', 'legendText', 'longitudeValuePath', 'offset', 'opacity', 'query', 'selectionSettings', 'shape', 'shapeValuePath', 'template', 'tooltipSettings', 'visible', 'width'];
let outputs$1 = [];
/**
 * Layer Directive
 * ```html
 * <e-layers>
 * <e-layer>
 * <e-markerSettings>
 * <e-markerSetting>
 * </e-markerSetting>
 * </e-markerSettings>
 * </e-layer>
 * </e-layers>
 * ```
 */
class MarkerDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$1);
        this.directivePropList = input$1;
    }
}
MarkerDirective.ɵfac = function MarkerDirective_Factory(t) { return new (t || MarkerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
MarkerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MarkerDirective, selectors: [["e-markerSetting"]], contentQueries: function MarkerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipSettings_template = _t.first);
    } }, inputs: { animationDelay: "animationDelay", animationDuration: "animationDuration", border: "border", colorValuePath: "colorValuePath", dashArray: "dashArray", dataSource: "dataSource", fill: "fill", height: "height", highlightSettings: "highlightSettings", imageUrl: "imageUrl", imageUrlValuePath: "imageUrlValuePath", initialMarkerSelection: "initialMarkerSelection", latitudeValuePath: "latitudeValuePath", legendText: "legendText", longitudeValuePath: "longitudeValuePath", offset: "offset", opacity: "opacity", query: "query", selectionSettings: "selectionSettings", shape: "shape", shapeValuePath: "shapeValuePath", template: "template", tooltipSettings: "tooltipSettings", visible: "visible", width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
MarkerDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
MarkerDirective.propDecorators = {
    'template': [{ type: ContentChild, args: ['template',] },],
    'tooltipSettings_template': [{ type: ContentChild, args: ['tooltipSettingsTemplate',] },],
};
__decorate([
    Template(),
    __metadata("design:type", Object)
], MarkerDirective.prototype, "template", void 0);
__decorate([
    Template(),
    __metadata("design:type", Object)
], MarkerDirective.prototype, "tooltipSettings_template", void 0);
/**
 * Marker Array Directive
 */
class MarkersDirective extends ArrayBase {
    constructor() {
        super('markersettings');
    }
}
MarkersDirective.ɵfac = function MarkersDirective_Factory(t) { return new (t || MarkersDirective)(); };
MarkersDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MarkersDirective, selectors: [["e-markerSettings"]], contentQueries: function MarkersDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MarkerDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
MarkersDirective.ctorParameters = () => [];

let input$2 = ['color', 'from', 'label', 'maxOpacity', 'minOpacity', 'showLegend', 'to', 'value'];
let outputs$2 = [];
/**
 * ColorMapping Directive
 * ```html
 * <e-layers>
 * <e-layer>
 * <e-bubbleSettings>
 * <e-colorMappings>
 * <e-colorMapping>
 * </e-colorMapping>
 * </e-colorMappings>
 * </e-bubbleSettings>
 * </e-layer>
 * </e-layers>
 * ```
 */
class ColorMappingDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$2);
        this.directivePropList = input$2;
    }
}
ColorMappingDirective.ɵfac = function ColorMappingDirective_Factory(t) { return new (t || ColorMappingDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
ColorMappingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColorMappingDirective, selectors: [["e-colorMapping"]], inputs: { color: "color", from: "from", label: "label", maxOpacity: "maxOpacity", minOpacity: "minOpacity", showLegend: "showLegend", to: "to", value: "value" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
ColorMappingDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
/**
 * ColorMapping Array Directive
 */
class ColorMappingsDirective extends ArrayBase {
    constructor() {
        super('colormapping');
    }
}
ColorMappingsDirective.ɵfac = function ColorMappingsDirective_Factory(t) { return new (t || ColorMappingsDirective)(); };
ColorMappingsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColorMappingsDirective, selectors: [["e-colorMappings"]], contentQueries: function ColorMappingsDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColorMappingDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
ColorMappingsDirective.ctorParameters = () => [];

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let input$3 = ['animationDelay', 'animationDuration', 'border', 'bubbleType', 'colorMapping', 'colorValuePath', 'dataSource', 'fill', 'highlightSettings', 'maxRadius', 'minRadius', 'opacity', 'query', 'selectionSettings', 'tooltipSettings', 'valuePath', 'visible'];
let outputs$3 = [];
/**
 * Layer Directive
 * ```html
 * <e-layers>
 * <e-layer>
 * <e-bubbleSettings>
 * <e-bubbleSetting>
 * </e-bubbleSetting>
 * </e-bubbleSettings>
 * </e-layer>
 * </e-layers>
 * ```
 */
class BubbleDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        this.tags = ['colorMapping'];
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$3);
        this.directivePropList = input$3;
    }
}
BubbleDirective.ɵfac = function BubbleDirective_Factory(t) { return new (t || BubbleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
BubbleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BubbleDirective, selectors: [["e-bubbleSetting"]], contentQueries: function BubbleDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c1, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, ColorMappingsDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipSettings_template = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childColorMapping = _t.first);
    } }, inputs: { animationDelay: "animationDelay", animationDuration: "animationDuration", border: "border", bubbleType: "bubbleType", colorMapping: "colorMapping", colorValuePath: "colorValuePath", dataSource: "dataSource", fill: "fill", highlightSettings: "highlightSettings", maxRadius: "maxRadius", minRadius: "minRadius", opacity: "opacity", query: "query", selectionSettings: "selectionSettings", tooltipSettings: "tooltipSettings", valuePath: "valuePath", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
BubbleDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
BubbleDirective.propDecorators = {
    'tooltipSettings_template': [{ type: ContentChild, args: ['tooltipSettingsTemplate',] },],
};
__decorate$1([
    Template(),
    __metadata$1("design:type", Object)
], BubbleDirective.prototype, "tooltipSettings_template", void 0);
/**
 * Bubble Array Directive
 */
class BubblesDirective extends ArrayBase {
    constructor() {
        super('bubblesettings');
    }
}
BubblesDirective.ɵfac = function BubblesDirective_Factory(t) { return new (t || BubblesDirective)(); };
BubblesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BubblesDirective, selectors: [["e-bubbleSettings"]], contentQueries: function BubblesDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, BubbleDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
BubblesDirective.ctorParameters = () => [];

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let input$4 = ['angle', 'arrowSettings', 'color', 'dashArray', 'highlightSettings', 'latitude', 'longitude', 'selectionSettings', 'visible', 'width'];
let outputs$4 = [];
/**
 * Layer Directive
 * ```html
 * <e-layers>
 * <e-layer>
 * <e-navigationLineSettings>
 * <e-navigationLineSetting>
 * </e-navigationLineSetting>
 * </e-navigationLineSettings>
 * </e-layer>
 * </e-layers>
 * ```
 */
class NavigationLineDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$4);
        this.directivePropList = input$4;
    }
}
NavigationLineDirective.ɵfac = function NavigationLineDirective_Factory(t) { return new (t || NavigationLineDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NavigationLineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavigationLineDirective, selectors: [["e-navigationLineSetting"]], contentQueries: function NavigationLineDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipSettings_template = _t.first);
    } }, inputs: { angle: "angle", arrowSettings: "arrowSettings", color: "color", dashArray: "dashArray", highlightSettings: "highlightSettings", latitude: "latitude", longitude: "longitude", selectionSettings: "selectionSettings", visible: "visible", width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
NavigationLineDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
NavigationLineDirective.propDecorators = {
    'tooltipSettings_template': [{ type: ContentChild, args: ['tooltipSettingsTemplate',] },],
};
__decorate$2([
    Template(),
    __metadata$2("design:type", Object)
], NavigationLineDirective.prototype, "tooltipSettings_template", void 0);
/**
 * NavigationLine Array Directive
 */
class NavigationLinesDirective extends ArrayBase {
    constructor() {
        super('navigationlinesettings');
    }
}
NavigationLinesDirective.ɵfac = function NavigationLinesDirective_Factory(t) { return new (t || NavigationLinesDirective)(); };
NavigationLinesDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NavigationLinesDirective, selectors: [["e-navigationLineSettings"]], contentQueries: function NavigationLinesDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationLineDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
NavigationLinesDirective.ctorParameters = () => [];

let input$5 = ['animationDuration', 'bingMapType', 'bubbleSettings', 'dataLabelSettings', 'dataSource', 'geometryType', 'highlightSettings', 'initialShapeSelection', 'key', 'layerType', 'markerClusterSettings', 'markerSettings', 'navigationLineSettings', 'query', 'selectionSettings', 'shapeData', 'shapeDataPath', 'shapePropertyPath', 'shapeSettings', 'staticMapType', 'toggleLegendSettings', 'tooltipSettings', 'type', 'urlTemplate', 'visible'];
let outputs$5 = [];
/**
 * Layer Directive
 * ```html
 * <e-layers>
 * <e-layer></e-layer>
 * </e-layers>
 * ```
 */
class LayerDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        this.tags = ['initialShapeSelection', 'markerSettings', 'bubbleSettings', 'navigationLineSettings'];
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$5);
        this.directivePropList = input$5;
    }
}
LayerDirective.ɵfac = function LayerDirective_Factory(t) { return new (t || LayerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
LayerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LayerDirective, selectors: [["e-layer"]], contentQueries: function LayerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, InitialShapeSelectionsDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, MarkersDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, BubblesDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigationLinesDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childInitialShapeSelection = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childMarkerSettings = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childBubbleSettings = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childNavigationLineSettings = _t.first);
    } }, inputs: { animationDuration: "animationDuration", bingMapType: "bingMapType", bubbleSettings: "bubbleSettings", dataLabelSettings: "dataLabelSettings", dataSource: "dataSource", geometryType: "geometryType", highlightSettings: "highlightSettings", initialShapeSelection: "initialShapeSelection", key: "key", layerType: "layerType", markerClusterSettings: "markerClusterSettings", markerSettings: "markerSettings", navigationLineSettings: "navigationLineSettings", query: "query", selectionSettings: "selectionSettings", shapeData: "shapeData", shapeDataPath: "shapeDataPath", shapePropertyPath: "shapePropertyPath", shapeSettings: "shapeSettings", staticMapType: "staticMapType", toggleLegendSettings: "toggleLegendSettings", tooltipSettings: "tooltipSettings", type: "type", urlTemplate: "urlTemplate", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
LayerDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
/**
 * Layer Array Directive
 */
class LayersDirective extends ArrayBase {
    constructor() {
        super('layers');
    }
}
LayersDirective.ɵfac = function LayersDirective_Factory(t) { return new (t || LayersDirective)(); };
LayersDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LayersDirective, selectors: [["e-layers"]], contentQueries: function LayersDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LayerDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
LayersDirective.ctorParameters = () => [];

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let input$6 = ['content', 'horizontalAlignment', 'verticalAlignment', 'x', 'y', 'zIndex'];
let outputs$6 = [];
/**
 * Annotation Directive
 * ```html
 * <e-maps-annotations>
 * <e-maps-annotation></e-maps-annotation>
 * </e-maps-annotations>
 * ```
 */
class AnnotationDirective extends ComplexBase {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        super();
        this.viewContainerRef = viewContainerRef;
        setValue('currentInstance', this, this.viewContainerRef);
        this.registerEvents(outputs$6);
        this.directivePropList = input$6;
    }
}
AnnotationDirective.ɵfac = function AnnotationDirective_Factory(t) { return new (t || AnnotationDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
AnnotationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AnnotationDirective, selectors: [["e-maps-annotation"]], contentQueries: function AnnotationDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c2, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, inputs: { content: "content", horizontalAlignment: "horizontalAlignment", verticalAlignment: "verticalAlignment", x: "x", y: "y", zIndex: "zIndex" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
AnnotationDirective.ctorParameters = () => [
    { type: ViewContainerRef, },
];
AnnotationDirective.propDecorators = {
    'content': [{ type: ContentChild, args: ['content',] },],
};
__decorate$3([
    Template(),
    __metadata$3("design:type", Object)
], AnnotationDirective.prototype, "content", void 0);
/**
 * Annotation Array Directive
 */
class AnnotationsDirective extends ArrayBase {
    constructor() {
        super('annotations');
    }
}
AnnotationsDirective.ɵfac = function AnnotationsDirective_Factory(t) { return new (t || AnnotationsDirective)(); };
AnnotationsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AnnotationsDirective, selectors: [["e-maps-annotations"]], contentQueries: function AnnotationsDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, AnnotationDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @nocollapse
 */
AnnotationsDirective.ctorParameters = () => [];

var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const inputs = ['allowImageExport', 'allowPdfExport', 'allowPrint', 'annotations', 'background', 'baseLayerIndex', 'border', 'centerPosition', 'description', 'enablePersistence', 'enableRtl', 'format', 'height', 'layers', 'legendSettings', 'locale', 'mapsArea', 'margin', 'projectionType', 'tabIndex', 'theme', 'titleSettings', 'tooltipDisplayMode', 'useGroupingSeparator', 'width', 'zoomSettings'];
const outputs$7 = ['animationComplete', 'annotationRendering', 'beforePrint', 'bubbleClick', 'bubbleMouseMove', 'bubbleRendering', 'click', 'dataLabelRendering', 'doubleClick', 'itemHighlight', 'itemSelection', 'layerRendering', 'legendRendering', 'load', 'loaded', 'markerClick', 'markerClusterClick', 'markerClusterMouseMove', 'markerClusterRendering', 'markerMouseMove', 'markerRendering', 'pan', 'resize', 'rightClick', 'shapeHighlight', 'shapeRendering', 'shapeSelected', 'tooltipRender', 'tooltipRenderComplete', 'zoom', 'dataSourceChange'];
const twoWays = ['dataSource'];
/**
 * Represents Maps Component
 * ```html
 * <ej-maps></ej-maps>
 * ```
 */
let MapsComponent = class MapsComponent extends Maps {
    /**
     * @param {?} ngEle
     * @param {?} srenderer
     * @param {?} viewContainerRef
     * @param {?} injector
     */
    constructor(ngEle, srenderer, viewContainerRef, injector) {
        super();
        this.ngEle = ngEle;
        this.srenderer = srenderer;
        this.viewContainerRef = viewContainerRef;
        this.injector = injector;
        this.tags = ['layers', 'annotations'];
        this.element = this.ngEle.nativeElement;
        this.injectedModules = this.injectedModules || [];
        try {
            let mod = this.injector.get('MapsBubble');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_a) { }
        try {
            let mod = this.injector.get('MapsLegend');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_b) { }
        try {
            let mod = this.injector.get('MapsMarker');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_c) { }
        try {
            let mod = this.injector.get('MapsHighlight');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_d) { }
        try {
            let mod = this.injector.get('MapsSelection');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_e) { }
        try {
            let mod = this.injector.get('MapsMapsTooltip');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_f) { }
        try {
            let mod = this.injector.get('MapsZoom');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_g) { }
        try {
            let mod = this.injector.get('MapsDataLabel');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_h) { }
        try {
            let mod = this.injector.get('MapsNavigationLine');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_j) { }
        try {
            let mod = this.injector.get('MapsAnnotations');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_k) { }
        try {
            let mod = this.injector.get('MapsPrint');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_l) { }
        try {
            let mod = this.injector.get('MapsPdfExport');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_m) { }
        try {
            let mod = this.injector.get('MapsImageExport');
            if (this.injectedModules.indexOf(mod) === -1) {
                this.injectedModules.push(mod);
            }
        }
        catch (_o) { }
        this.registerEvents(outputs$7);
        this.addTwoWay.call(this, twoWays);
        setValue('currentInstance', this, this.viewContainerRef);
        this.context = new ComponentBase();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.context.ngOnInit(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.context.ngAfterViewInit(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.context.ngOnDestroy(this);
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.tagObjects[0].instance = this.childLayers;
        if (this.childAnnotations) {
            this.tagObjects[1].instance = /** @type {?} */ (this.childAnnotations);
        }
        this.context.ngAfterContentChecked(this);
    }
};
MapsComponent.ɵfac = function MapsComponent_Factory(t) { return new (t || MapsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
MapsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MapsComponent, selectors: [["ejs-maps"]], contentQueries: function MapsComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, LayersDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, AnnotationsDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childLayers = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childAnnotations = _t.first);
    } }, inputs: { allowImageExport: "allowImageExport", allowPdfExport: "allowPdfExport", allowPrint: "allowPrint", annotations: "annotations", background: "background", baseLayerIndex: "baseLayerIndex", border: "border", centerPosition: "centerPosition", description: "description", enablePersistence: "enablePersistence", enableRtl: "enableRtl", format: "format", height: "height", layers: "layers", legendSettings: "legendSettings", locale: "locale", mapsArea: "mapsArea", margin: "margin", projectionType: "projectionType", tabIndex: "tabIndex", theme: "theme", titleSettings: "titleSettings", tooltipDisplayMode: "tooltipDisplayMode", useGroupingSeparator: "useGroupingSeparator", width: "width", zoomSettings: "zoomSettings" }, outputs: { animationComplete: "animationComplete", annotationRendering: "annotationRendering", beforePrint: "beforePrint", bubbleClick: "bubbleClick", bubbleMouseMove: "bubbleMouseMove", bubbleRendering: "bubbleRendering", click: "click", dataLabelRendering: "dataLabelRendering", doubleClick: "doubleClick", itemHighlight: "itemHighlight", itemSelection: "itemSelection", layerRendering: "layerRendering", legendRendering: "legendRendering", load: "load", loaded: "loaded", markerClick: "markerClick", markerClusterClick: "markerClusterClick", markerClusterMouseMove: "markerClusterMouseMove", markerClusterRendering: "markerClusterRendering", markerMouseMove: "markerMouseMove", markerRendering: "markerRendering", pan: "pan", resize: "resize", rightClick: "rightClick", shapeHighlight: "shapeHighlight", shapeRendering: "shapeRendering", shapeSelected: "shapeSelected", tooltipRender: "tooltipRender", tooltipRenderComplete: "tooltipRenderComplete", zoom: "zoom", dataSourceChange: "dataSourceChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function MapsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
/**
 * @nocollapse
 */
MapsComponent.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ViewContainerRef, },
    { type: Injector, },
];
MapsComponent = __decorate$4([
    ComponentMixins([ComponentBase]),
    __metadata$4("design:paramtypes", [ElementRef,
        Renderer2,
        ViewContainerRef,
        Injector])
], MapsComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InitialShapeSelectionDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-initialShapeSelections>e-initialShapeSelection',
                inputs: input,
                outputs: outputs,
                queries: {}
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InitialShapeSelectionsDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-initialShapeSelections',
                queries: {
                    children: new ContentChildren(InitialShapeSelectionDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MarkerDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-markerSettings>e-markerSetting',
                inputs: input$1,
                outputs: outputs$1,
                queries: {}
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { template: [{
            type: ContentChild,
            args: ['template']
        }], tooltipSettings_template: [{
            type: ContentChild,
            args: ['tooltipSettingsTemplate']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MarkersDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-markerSettings',
                queries: {
                    children: new ContentChildren(MarkerDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorMappingDirective, [{
        type: Directive,
        args: [{
                selector: 'e-bubbleSettings>e-colorMappings>e-colorMapping',
                inputs: input$2,
                outputs: outputs$2,
                queries: {}
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColorMappingsDirective, [{
        type: Directive,
        args: [{
                selector: 'e-bubbleSettings>e-colorMappings',
                queries: {
                    children: new ContentChildren(ColorMappingDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-bubbleSettings>e-bubbleSetting',
                inputs: input$3,
                outputs: outputs$3,
                queries: {
                    childColorMapping: new ContentChild(ColorMappingsDirective)
                }
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { tooltipSettings_template: [{
            type: ContentChild,
            args: ['tooltipSettingsTemplate']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubblesDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-bubbleSettings',
                queries: {
                    children: new ContentChildren(BubbleDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationLineDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-navigationLineSettings>e-navigationLineSetting',
                inputs: input$4,
                outputs: outputs$4,
                queries: {}
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { tooltipSettings_template: [{
            type: ContentChild,
            args: ['tooltipSettingsTemplate']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NavigationLinesDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layer>e-navigationLineSettings',
                queries: {
                    children: new ContentChildren(NavigationLineDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LayerDirective, [{
        type: Directive,
        args: [{
                selector: 'e-layers>e-layer',
                inputs: input$5,
                outputs: outputs$5,
                queries: {
                    childInitialShapeSelection: new ContentChild(InitialShapeSelectionsDirective),
                    childMarkerSettings: new ContentChild(MarkersDirective),
                    childBubbleSettings: new ContentChild(BubblesDirective),
                    childNavigationLineSettings: new ContentChild(NavigationLinesDirective)
                }
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LayersDirective, [{
        type: Directive,
        args: [{
                selector: 'ej-maps>e-layers',
                queries: {
                    children: new ContentChildren(LayerDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnnotationDirective, [{
        type: Directive,
        args: [{
                selector: 'e-maps-annotations>e-maps-annotation',
                inputs: input$6,
                outputs: outputs$6,
                queries: {}
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { content: [{
            type: ContentChild,
            args: ['content']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnnotationsDirective, [{
        type: Directive,
        args: [{
                selector: 'ej-maps>e-maps-annotations',
                queries: {
                    children: new ContentChildren(AnnotationDirective)
                }
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MapsComponent, [{
        type: Component,
        args: [{
                selector: 'ejs-maps',
                inputs: inputs,
                outputs: outputs$7,
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush,
                queries: {
                    childLayers: new ContentChild(LayersDirective),
                    childAnnotations: new ContentChild(AnnotationsDirective)
                }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }]; }, null); })();

/**
 * NgModule definition for the Maps component.
 */
class MapsModule {
}
MapsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MapsModule });
MapsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MapsModule_Factory(t) { return new (t || MapsModule)(); }, imports: [[CommonModule]] });
/**
 * @nocollapse
 */
MapsModule.ctorParameters = () => [];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MapsModule, { declarations: function () { return [MapsComponent, InitialShapeSelectionDirective, InitialShapeSelectionsDirective, MarkerDirective, MarkersDirective, ColorMappingDirective, ColorMappingsDirective, BubbleDirective, BubblesDirective, NavigationLineDirective, NavigationLinesDirective, LayerDirective, LayersDirective, AnnotationDirective, AnnotationsDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [MapsComponent, InitialShapeSelectionDirective, InitialShapeSelectionsDirective, MarkerDirective, MarkersDirective, ColorMappingDirective, ColorMappingsDirective, BubbleDirective, BubblesDirective, NavigationLineDirective, NavigationLinesDirective, LayerDirective, LayersDirective, AnnotationDirective, AnnotationsDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MapsModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [
                    MapsComponent,
                    InitialShapeSelectionDirective,
                    InitialShapeSelectionsDirective,
                    MarkerDirective,
                    MarkersDirective,
                    ColorMappingDirective,
                    ColorMappingsDirective,
                    BubbleDirective,
                    BubblesDirective,
                    NavigationLineDirective,
                    NavigationLinesDirective,
                    LayerDirective,
                    LayersDirective,
                    AnnotationDirective,
                    AnnotationsDirective
                ],
                exports: [
                    MapsComponent,
                    InitialShapeSelectionDirective,
                    InitialShapeSelectionsDirective,
                    MarkerDirective,
                    MarkersDirective,
                    ColorMappingDirective,
                    ColorMappingsDirective,
                    BubbleDirective,
                    BubblesDirective,
                    NavigationLineDirective,
                    NavigationLinesDirective,
                    LayerDirective,
                    LayersDirective,
                    AnnotationDirective,
                    AnnotationsDirective
                ]
            }]
    }], null, null); })();

const BubbleService = { provide: 'MapsBubble', useValue: Bubble };
const LegendService = { provide: 'MapsLegend', useValue: Legend };
const MarkerService = { provide: 'MapsMarker', useValue: Marker };
const HighlightService = { provide: 'MapsHighlight', useValue: Highlight };
const SelectionService = { provide: 'MapsSelection', useValue: Selection };
const MapsTooltipService = { provide: 'MapsMapsTooltip', useValue: MapsTooltip };
const ZoomService = { provide: 'MapsZoom', useValue: Zoom };
const DataLabelService = { provide: 'MapsDataLabel', useValue: DataLabel };
const NavigationLineService = { provide: 'MapsNavigationLine', useValue: NavigationLine };
const AnnotationsService = { provide: 'MapsAnnotations', useValue: Annotations };
const PrintService = { provide: 'MapsPrint', useValue: Print };
const PdfExportService = { provide: 'MapsPdfExport', useValue: PdfExport };
const ImageExportService = { provide: 'MapsImageExport', useValue: ImageExport };
/**
 * NgModule definition for the Maps component with providers.
 */
class MapsAllModule {
}
MapsAllModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MapsAllModule });
MapsAllModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MapsAllModule_Factory(t) { return new (t || MapsAllModule)(); }, providers: [
        BubbleService,
        LegendService,
        MarkerService,
        HighlightService,
        SelectionService,
        MapsTooltipService,
        ZoomService,
        DataLabelService,
        NavigationLineService,
        AnnotationsService,
        PrintService,
        PdfExportService,
        ImageExportService
    ], imports: [[CommonModule, MapsModule], MapsModule] });
/**
 * @nocollapse
 */
MapsAllModule.ctorParameters = () => [];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MapsAllModule, { imports: function () { return [CommonModule, MapsModule]; }, exports: function () { return [MapsModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MapsAllModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, MapsModule],
                exports: [
                    MapsModule
                ],
                providers: [
                    BubbleService,
                    LegendService,
                    MarkerService,
                    HighlightService,
                    SelectionService,
                    MapsTooltipService,
                    ZoomService,
                    DataLabelService,
                    NavigationLineService,
                    AnnotationsService,
                    PrintService,
                    PdfExportService,
                    ImageExportService
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { InitialShapeSelectionDirective, InitialShapeSelectionsDirective, MarkerDirective, MarkersDirective, ColorMappingDirective, ColorMappingsDirective, BubbleDirective, BubblesDirective, NavigationLineDirective, NavigationLinesDirective, LayerDirective, LayersDirective, AnnotationDirective, AnnotationsDirective, MapsComponent, MapsModule, MapsAllModule, BubbleService, LegendService, MarkerService, HighlightService, SelectionService, MapsTooltipService, ZoomService, DataLabelService, NavigationLineService, AnnotationsService, PrintService, PdfExportService, ImageExportService, inputs as ɵa, outputs$7 as ɵb };
export { Maps, load, loaded, click, rightClick, doubleClick, resize, tooltipRender, shapeSelected, shapeHighlight, mousemove, mouseup, mousedown, layerRendering, shapeRendering, markerRendering, markerClusterRendering, markerClick, markerClusterClick, markerMouseMove, markerClusterMouseMove, dataLabelRendering, bubbleRendering, bubbleClick, bubbleMouseMove, animationComplete, legendRendering, annotationRendering, itemSelection, itemHighlight, beforePrint, zoomIn, zoomOut, pan, Annotation, Arrow, Font, Border, CenterPosition, TooltipSettings, Margin, ConnectorLineSettings, MarkerClusterSettings, MarkerClusterData, ColorMappingSettings, InitialMarkerSelectionSettings, InitialShapeSelectionSettings, SelectionSettings, HighlightSettings, NavigationLineSettings, BubbleSettings, CommonTitleSettings, SubTitleSettings, TitleSettings, ZoomSettings, ToggleLegendSettings, LegendSettings, DataLabelSettings, ShapeSettings, MarkerBase, MarkerSettings, LayerSettings, Tile, MapsAreaSettings, Size, stringToNumber, calculateSize, createSvg, getMousePosition, degreesToRadians, radiansToDegrees, convertGeoToPoint, convertTileLatLongToPoint, xToCoordinate, yToCoordinate, aitoff, roundTo, sinci, acos, calculateBound, triggerDownload, Point, MinMax, GeoLocation, measureText, TextOption, PathOption, ColorValue, RectOption, CircleOption, PolygonOption, PolylineOption, LineOption, Line, MapLocation, Rect, PatternOptions, renderTextElement, convertElement, formatValue, convertStringToValue, convertElementFromLabel, drawSymbols, getValueFromObject, markerColorChoose, markerShapeChoose, clusterTemplate, mergeSeparateCluster, clusterSeparate, marker, markerTemplate, maintainSelection, maintainStyleClass, appendShape, drawCircle, drawRectangle, drawPath, drawPolygon, drawPolyline, drawLine, calculateShapes, drawDiamond, drawTriangle, drawCross, drawHorizontalLine, drawVerticalLine, drawStar, drawBalloon, drawPattern, getFieldData, checkShapeDataFields, checkPropertyPath, filter, getRatioOfBubble, findMidPointOfPolygon, isCustomPath, textTrim, findPosition, removeElement, calculateCenterFromPixel, getTranslate, getZoomTranslate, fixInitialScaleForTile, getElementByID, Internalize, getTemplateFunction, getElement, getShapeData, triggerShapeEvent, getElementsByClassName, querySelector, getTargetElement, createStyle, customizeStyle, triggerItemSelectionEvent, removeClass, elementAnimate, timeout, showTooltip, wordWrap, createTooltip, drawSymbol, renderLegendShape, getElementOffset, changeBorderWidth, changeNavaigationLineWidth, targetTouches, calculateScale, getDistance, getTouches, getTouchCenter, sum, zoomAnimate, animate, MapAjax, smoothTranslate, compareZoomFactor, calculateZoomLevel, processResult, LayerPanel, Bubble, BingMap, Marker, ColorMapping, DataLabel, NavigationLine, Legend, Highlight, Selection, MapsTooltip, Zoom, Annotations, Print, ImageExport, PdfExport } from '@syncfusion/ej2-maps';

//# sourceMappingURL=ej2-angular-maps.js.map